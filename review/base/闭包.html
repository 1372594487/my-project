<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        #app {
            width: 40px;
            height: 40px;
            background-color: brown;
        }
    </style>
</head>

<body>
    <div id="app"></div>
    <script src="../tool/jquery/jquery-3.4.1.js"></script>
    <script>
        //闭包：有权访问函数的局部变量的函数
        //闭包优点：避免全局污染
        // 1.保护函数内变量安全
        // 2.在内存中维持一个变量
        //闭包缺点：造成内存泄漏 (内存泄漏：本应该释放内存，而不能释放)
        //由于闭包会携带包含它的函数的作用域，因为会比其他函数占用更多内容，过度使用闭包，会导致内存占用过多。

        //坑1.this 的指向问题
        var object = {
            aname: "object",
            getName: function () {
                return function () {
                    console.info(this.aname)
                }
            }
        }
        console.log(name);
        var a = object.getName();
        console.log(a());
        // object.getName()() // underfined
        // 因为里面的闭包函数是在window作用域下执行的，也就是说，this指向windows


        //20201020
        var bname = '小王',age = 17;
        var obj = {
            bname: '小张',
            objAge: this.age,
            myFun: function () {
                console.log(this.bname + "年龄" + this.age);
            }
        }
        console.log(obj.objAge);
        // 17
        obj.myFun()
        // 小张年龄undefined



        //为什么不是指向对象中的name ？ 看下边的例子
        var a = 3;
        var object = {
            a: 2,
            run: function () {
                console.log(a); //a=3;
                console.log(this.a)
            }
        };
        object.run();
        // a为什么不是2 ?
        // a:2表示object这个对象里"a"属性的值等于2。js里以函数为作用域划分，object里面的a并不是一个单独的变量，要访问它只能通过object.a

        // 坑2 引用的变量可能发生变化
        function outer() {
            var result = []
            for (var i = 0; i < 10; i++) {
                result[i] = function () {
                    console.info(i) //10
                }
            }
            return result
        }
        

        //坑3.内存泄漏问题
        // function showId() {
        //     var el = document.getElementById("app")
        //     el.onclick = function () {
        //         console.log(el.id); // 这样会导致闭包引用外层的el，当执行完showId后，el无法释放
        //     }
        // }

        // 改成下面
        function showId() {
            var el = document.getElementById("app")
            var id = el.id
            el.onclick = function () {
                console.log(id);
            }
            el = null // 主动释放el
        }
        showId();

        //技巧1 用闭包解决递归调用问题
        function factorial(num) {
            if (num <= 1) {
                return 1
            } else {
                return num * arguments.callee(num - 1)
            }
        }
        var anotherFactorial = factorial
        factorial = null
        anotherFactorial(4)
        // 报错 ，因为最好是return num* arguments.callee（num-1），arguments.callee指向当前执行函数，但是在严格模式下不能使用该属性也会报错，所以借助闭包来实现


        // // 使用闭包实现递归
        // function newFactorial = (function f(num){
        //     if(num<1) {return 1}
        //     else {
        //        return num* f(num-1)
        //     }
        // }) //这样就没有问题了，实际上起作用的是闭包函数f，而不是外面的函数newFactorial

        //思考
        var namea = "The Window";
        var objecta = {
            namea: "My Object",
            getNameFunc: function () {
                return function () {
                    return this.namea;
                };
            }
        };
        console.log(objecta.getNameFunc()());

        var nameb = "The Window";
        var objectb = {
            nameb: "My Object",
            getNameFunc: function () {
                var that = this;
                return function () {
                    return that.nameb;
                };
            }
        };
        alert(objectb.getNameFunc()());

        //内部函数可以访问定义它们的外部函数的参数和变量（除了this和arguments之外）
        function aa(a, b, c) {
            console.log(this);
            console.log(arguments);
            return function () {
                console.log("bb =>", this);
                var that = this;
                console.log("bb =>", that);
                console.log(arguments);
            }
        }
        aa(1, a, 4)()
        // 如果需要访问对象的name属性的话，就需要显示的定义一个变量that来引用this，而这个变量此时就指向object对象了。

        // 第一题改成下面这样就很清楚了。getNameFunc的第一个()是属于方法调用，所以this绑定到了object对象，自然this.name为"My Object"，但是闭包函数无法访问这个this(js里以函数为作用域划分 上边也写有)，它只能访问到全局的this。    
    </script>
</body>

</html>