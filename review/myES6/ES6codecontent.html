<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ES6核心内容（上）</title>
    <style>
        .clickBox {
            width: 200px;
            height: 50px;
            border: black 1px solid;
            font-size: 20px;

            display: flex;
            align-items: center;
            justify-content: center;

            margin: 50px auto;
            transition: all 0.3s;

        }

        .clickBox:hover {
            cursor: pointer;
            width: 220px;
            height: 55px;
        }
    </style>
</head>

<body>
    <div class="clickBox">
        clickBox1
    </div>
    <div class="clickBox">
        clickBox2
    </div>
    <div class="clickBox">
        clickBox3
    </div>
    <div class="clickBox">
        clickBox4
    </div>



    <script>
        console.log(
            `ECMAScript 6（以下简称ES6）是JavaScript语言的下一代标准。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。也就是说，ES6就是ES2015。

　　虽然目前并不是所有浏览器都能兼容ES6全部特性，但越来越多的程序员在实际项目当中已经开始使用ES6了。所以就算你现在不打算使用ES6，但为了看懂别人的你也该懂点ES6的语法了...

　　在我们正式讲解ES6语法之前，我们得先了解下Babel。Babel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用Babel，具体过程可直接在Babel官网查看。

　　最常用的ES6特性：let, const, class, extends, super, arrow functions, template string, destructuring, default, rest arguments。这些是ES6最常用的几个语法 `
        )
        //
        //let,const
        //


        //var 使用的不合理场景1：
        // var name = 'zach'

        // while (true) {
        //     var name = 'obama'
        //     console.log(name) //obama
        //     break
        // }

        // console.log(name) //obama

        //使用 var 两次输出都是 obama ，这是因为ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。第一种场景就是你现在看到的内层变量覆盖外层变量。（内层覆盖外层的变量可能不大好理解，其实就是后面的赋值覆盖了前面的）

        //而 let 则实际上为JavaScript新增了块级作用域。用它所声明的变量，只在let命令所在的代码块内有效。

        let name = 'zach'

        while (true) {
            let name = 'obama'
            console.log(name) //obama
            break
        }

        console.log(name) //zach

        // 另外一个var带来的不合理场景就是用来计数的循环变量泄露为全局变量，看下面的例子：

        // var a = [];
        // for (var i = 0; i < 10; i++) {
        //     a[i] = function () {
        //         console.log(i);
        //     };
        // }
        // a[6](); // 10

        // 上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的 i 值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用let则不会出现这个问题。

        //下面是使用 let 声明

        // var a = [];
        // for (let i = 0; i < 10; i++) {
        //     a[i] = function () {
        //         console.log(i);
        //     };
        // }
        // a[6](); // 6

        //　再来看一个更常见的例子，了解下如果不用ES6，而用闭包如何解决这个问题。

        var clickBoxs = document.querySelectorAll('.clickBox')
        for (var i = 0; i < clickBoxs.length; i++) {
            //这里人为给一个index值也可以
             clickBoxs[i].index = i;
            clickBoxs[i].onclick = function () {
                console.log("clickBoxs[i].onclick",i);
                console.log(`this => ${this} this.index ${this.index}`);
            }
        }

        //我们本来希望的是点击不同的clickBox，显示不同的i，但事实是无论我们点击哪个clickBox，输出的都是5。下面我们来看下，如何用闭包搞定它。
        // 闭包优点：避免全局污染
		// 1.保护函数内变量安全
		// 2.在内存中维持一个变量
        function iteratorFactory(i) {
            var onclick = function (e) {
                //
                console.log(`当前的事件 => ${e}`)
               //
                console.log("iteratorFactory(i) => ",i)
            }
            return onclick;
        }
        var clickBoxs = document.querySelectorAll('.clickBox');
        //检查
        console.log(clickBoxs);
        for (var i = 0; i < clickBoxs.length; i++) {
            clickBoxs[i].onclick = iteratorFactory(i)
        }

        //我自己的方法,用let写的话
        // var clickBoxs = document.querySelectorAll('.clickBox');
        // console.log(`type of clickBoxs =>  ${clickBoxs} , clickBoxs => ${clickBoxs}`);
        // console.log(`clickBoxs[1] => ${clickBoxs[1]}`)

        // for (let b = 0; b < clickBoxs.length; b++) {

        //     console.log("myfunction in for index", b);
        //     console.log("myfunction in for value", clickBoxs[b]);
        //     //clickBoxs[b].index = b;
        // }
        // // console.log("myfunction out for", b);//拿不到，let 块级作用域问题
        // console.log("myfunction out for value[random] ",clickBoxs[3]);


        

        // const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。

        const PI = Math.PI;
        //检查输出，Math.PI 圆周率 toFixed(n) 保留小数点后n位 
        console.log(`console.log(PI) => ${PI.toFixed(2)}`);

        try {
            PI = 23;

        } catch (error) {
            console.log(error);
        }
        //Module build failed: SyntaxError: /es6/app.js: "PI" is read-only

        //！！！ const 有一个很好的应用场景，就是当我们引用第三方库时，声明的变量用const来声明 可以避免未来不小心重命名而导致出现bug：
        // const monent = require('moment');


        //
        //
        //class, extends, super
        //
        //



        // 这三个特性涉及了ES5中最令人头疼的的几个部分：原型、构造函数，继承...你还在为它们复杂难懂的语法而烦恼吗？你还在为指针到底指向哪里而纠结万分吗？有了ES6我们不再烦恼！

        // 　　ES6提供了更接近传统语言的写法，引入了Class（类）这个概念。新的class写法让对象原型的写法更加清晰、更像面向对象编程的语法，也更加通俗易懂。

        console.log("\n---------------------------------------------------------------------------------------\n");



        // 其中 constructor 方法是类的构造函数， 是一个默认方法， 通过 new 命令创建对象实例时， 自动调用该方法。

        // 一个类必须有 constructor 方法， 如果没有显式定义， 一个默认的 consructor 方法会被默认添加。 所以即使你没有添加构造函数， 也是会有一个默认的构造函数的。 一般 constructor 方法返回实例对象 this， 但是也可以指定 constructor 方法返回一个全新的对象， 让返回的实例对象不是该类的实例。

        class Animal {
            constructor() {
                this.type = 'animal'
            }
            says(say) {
                console.log(this.type + ' says ' + say)
            }
        }

        let animal = new Animal()
        animal.says('hello') //animal says hello

        class Cat extends Animal {
            constructor() {
                // console.log(`this type => ${this}`);
                //Uncaught ReferenceError: Must call super constructor in derived
                // class before accessing 'this' or returning from derived constructor
                super()
                this.type = 'cat'
            }
        }

        let cat = new Cat()
        cat.says('hello') //cat says hello

        // 上面代码首先用class定义了一个“ 类”， 可以看到里面有一个constructor方法， 这就是构造方法， 而this关键字则代表实例对象。

        // 简单地说， constructor内定义的方法和属性是实例对象自己的， 而constructor外定义的方法和属性则是所有实例对象可以共享的。

        // Class之间可以通过extends关键字实现继承， 这比ES5的通过修改原型链实现继承， 要清晰和方便很多。 上面定义了一个Cat类， 该类通过extends关键字， 继承了Animal类的所有属性和方法。

        // super关键字， 它指代父类的实例（ 即父类的this对象）。 子类 必须 在constructor方法中调用super方法， 否则新建实例时会报错。 这是因为子类没有自己的this对象， 而是继承父类的this对象， 然后对其进行加工。 如果不调用super方法， 子类就得不到this对象。

        // ES6的继承机制， 实质是先创造父类的实例对象this（ 所以必须先调用super方法）， 然后再用子类的构造函数修改this。

        // P.S 如果你写react的话， 就会发现以上三个东西在最新版React中出现得很多。 创建的每个component都是一个继承React.Component的类。

        console.log("\n---------------------------------------------------------------------------------------\n");
        //
        //
        //arrow function
        //
        //



        // 这个恐怕是ES6最最常用的一个新特性了，用它来写function比原来的写法要简洁清晰很多：

        // function (i) {
        //     return i + 1;
        // } //ES5
        // (i) => i + 1 //ES6

        //如果方程比较复杂，则需要用{}把代码包起来：

        // function (x, y) {
        //     x++;
        //     y--;
        //     return x + y;
        // } //ES5
        // (x, y) => {
        //     x++;
        //     y--;
        //     return x + y
        // } //ES6





        // 除了看上去更简洁以外，arrow function还有一项超级无敌的功能！长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。例如：

        // class Animal {
        //     constructor() {
        //         this.type = 'animal'
        //     }
        //     says(say) {
        //         setTimeout(function () {
        //             console.log(this.type + ' says ' + say)
        //         }, 1000)
        //     }
        // }

        // var animal = new Animal()
        // animal.says('hi') //undefined says hi

        // 运行上面的代码会报错，这是因为setTimeout中的this指向的是全局对象。所以为了让它能够正确的运行，传统的解决方法有两种：


        // class Animal {
        //     constructor() {
        //         this.type = 'animal'
        //     }

        //     // 　　（1）第一种：this重定向，就是将this传给self，再用self来指代this
        //     // says(say) {
        //     //     var self = this;
        //     //     setTimeout(function () {
        //     //         console.log(self.type + ' says ' + say)
        //     //     }, 1000)
        //     // }

        //     // （2） 第二种方法是用bind(this)， 即
        //     says(say) {
        //         setTimeout(function () {
        //             console.log(this.type + ' says ' + say)
        //         }.bind(this), 1000)
        //     }

        //     // !!!（3）箭头函数，就不需要这么麻烦了：
        //     says(say) {
        //         setTimeout(() => {
        //             console.log(this.type + ' says ' + say)
        //         }, 1000)
        //     }
        //     // !!!当我们使用箭头函数时，函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。

        //     // 　　并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，它的this是继承外面的，因此内部的this就是外层代码块的this。
        // }
        // console.log(`this重定向之后输出的结果 =>`)
        // var animal = new Animal()
        // animal.says('hi')


        //template string
        //这个东西也是非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦，所以之前我们通常会引用一些模板工具库，比如mustache等等。大家可以先看下面一段代码：

        // $("#result").append(
        //     "There are <b>" + basket.count + "</b> " +
        //     "items in your basket, " +
        //     "<em>" + basket.onSale +
        //     "</em> are on sale!"
        // );

        // 我们要用一堆的'+'号来连接文本与变量，而使用ES6的新特性模板字符串``后，我们可以直接这么来写：

        // $("#result").append(`
        //   There are <b>${basket.count}</b> items
        //    in your basket, <em>${basket.onSale}</em>
        //   are on sale!
        // `);

        //用反引号（\）来标识起始，用 ${}  来引用变量，而且所有的空格和缩进都会被保留在输出之中

        // destructuring

        // ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。看下面的例子：

        // let cat = 'ken'
        // let dog = 'lili'
        // let zoo = {
        //     cat: cat,
        //     dog: dog
        // }
        // console.log(zoo) //Object {cat: "ken", dog: "lili"}

        // ES6完全可以像下面这么写：

        // let cat = 'ken'
        // let dog = 'lili'
        // let zoo = {
        //     cat,
        //     dog
        // }
        // console.log(zoo) //Object {cat: "ken", dog: "lili"}

        // 反过来可以这么写：
        // let dog = {
        //     type: 'animal',
        //     many: 2
        // }
        // let {
        //     type,
        //     many
        // } = dog
        // console.log(type, many) //animal 2

        // 最后一个rest语法也很简单，直接看例子：三个点
        // function animals(...types) {
        //     console.log(types)
        // }
        // console.log(
        //     `animals('cat', 'dog', 'fish','duck','lion') => ${animals('cat', 'dog', 'fish','duck','lion')}`
        //     ) //["cat", "dog", "fish"]...

        // 以上就是ES6最常用的一些语法


        //-----------------------------------------------------------------------------------------------------------------------------------

        //下篇

        // import
        // export
        // 这两个家伙对应的就是es6自己的module功能。

        // 我们之前写的Javascript一直都没有模块化的体系， 无法将一个庞大的js工程拆分成一个个功能相对独立但相互依赖的小工程， 再用一种简单的方法把这些小工程连接在一起。

        // 这有可能导致两个问题：

        // （ 1） 一方面js代码变得很臃肿， 难以维护

        // （ 2） 另一方面我们常常得很注意每个script标签在html中的位置， 因为它们通常有依赖关系， 顺序错了可能就会出bug

        // 在es6之前为解决上面提到的问题， 我们得利用第三方提供的一些方案， 主要有两种CommonJS（ 服务器端） 和AMD（ 浏览器端， 如require.js）。

        // 而现在我们有了es6的module功能， 它实现非常简单， 可以成为服务器和浏览器通用的模块解决方案。

        // ES6模块的设计思想， 是尽量的静态化， 使得编译时就能确定模块的依赖关系， 以及输入和输出的变量。 CommonJS和AMD模块， 都只能在运行时确定这些东西。

        // 上面的设计思想看不懂也没关系， 咱先学会怎么用， 等以后用多了、 熟练了再去研究它背后的设计思想也不迟！

        // 传统的写法
        // 首先我们回顾下require.js的写法。 假设我们有两个js文件: index.js和content.js, 现在我们想要在index.js中使用content.js返回的结果， 我们要怎么做呢？

        //首先定义：
        //content.js
        // define('content.js', function () {
        //     return 'A cat';
        // })
        // 然后require：

        //index.js
        // require(['./content.js'], function (animal) {
        //     console.log(animal); //A cat
        // })
        // 那CommonJS是怎么写的呢？

        //index.js
        // var animal = require('./content.js')

        //content.js
        // module.exports = 'A cat'

        // ES6的写法

        //index.js
        // import animal from './content'

        //content.js
        // export default 'A cat'

        // 以上我把三者都列出来了，妈妈再也不用担心我写混淆了...

        // ES6 module的其他高级用法

        //content.js

        // export default 'A cat'
        // export function say() {
        //     return 'Hello!'
        // }
        // export const type = 'dog'

        // 上面可以看出，export命令除了输出变量，还可以输出函数，甚至是类（react的模块基本都是输出类）

        //index.js

        // import {
        //     say,
        //     type
        // } from './content'
        // let says = say()
        // console.log(`The ${type} says ${says}`) //The dog says Hello

        // 这里输入的时候要注意： 大括号里面的变量名， 必须与被导入模块（ content.js） 对外接口的名称相同。

        // 如果还希望输入content.js中输出的默认值(
        //     default)， 可以写在大括号外面。

        //index.js

        // import animal, {
        //     say,
        //     type
        // } from './content'
        // let says = say()
        // console.log(`The ${type} says ${says} to ${animal}`)
        // //The dog says Hello to A cat
    </script>
</body>

</html>