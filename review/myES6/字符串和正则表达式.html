<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>字符串和正则表达式</title>
</head>

<body>
    <script>
        //codePointAt()方法
        function is32Bit(c) {
            return c.codePointAt(0) > 0xFFFF;
        }
        //console.log(is32Bit("𠮷")); //true 吉的异体字，拼音打不出来，如果是吉输出是false
        //console.log(is32Bit("a")); //false


        //String.fromCodePoint()方法
        //console.log(String.fromCodePoint(134071)); //"吉的异体字"


        //map()
        var arr = [10, 20, 30]
        var result = arr.map(function (item, index, array) {
            console.log(array[index])
            return item + 10
        })
        console.log(result);

        //normalize()方法
        // 写法1
        value = ["a", "b", "z", "Z", "A", "o", "0", "100", "中", "一"];

        // var values = value.join();
        // console.log(typeof values[0], values);

        let normalized = value.map(function (text) {
            //text = item
            // console.log(text);
            return text.normalize();
        });

        console.log("normalized =>" + normalized);

        normalized.sort(function (first, second) {
            if (first < second) {
                return -1;
            } else if (first === second) {
                return 0;
            } else {
                return 1;
            }
        });

        console.log(`由小到大排序 normalized.sort() =>${normalized}\n`);

        console.log(`------------------------------------------------------------\n`);

        //验证
        console.log("a.codePointAt(0)=>" + "a".codePointAt(0));
        console.log("z.codePointAt(0)=>" + "z".codePointAt(0));
        console.log("A.codePointAt(0)=>" + "A".codePointAt(0));
        console.log("'0'.codePointAt(0)=>" + "0".codePointAt(0));
        console.log("'100'.codePointAt(0)=>" + "100".codePointAt(0));

        console.log(`------------------------------------------------------------\n`);



        //写法2
        value = ["t", "r", "e", "e","A","A"];
        value.sort(function (first, second) {
            let firstNormalized = first.normalize();
            let seconNormalized = second.normalize();

            console.log("firstNormalized => ", firstNormalized);
            console.log("seconNormalized => ", seconNormalized);


            if (firstNormalized < seconNormalized) {
                return 1;

            } else if (first === seconNormalized) {
                return 0;
            } else {
                return -1;
            }

        });
        console.log(`写法2 value =>${value}`);


        //写法3
        value.sort(function (first, second) {
            let firstNormalized = first.normalize("NFD");
            let SecondNormalized = second.normalize("NFD");

            if (firstNormalized < SecondNormalized) {
                return -1;
            } else if (first === second) {
                return 0;
            } else {
                return 1;
            }
        })
        console.log(`写法3 value =>${value}`);



        console.log(`------------------------------------------------------------\n`);



        //写法4
        value.sort(function (first, second) {
            let firstNormalized = first.normalize("NFD");
            let SecondNormalized = second.normalize("NFD");

            firstNormalized - SecondNormalized;
        })
        console.log(`写法4 value =>${value}`);



        console.log(`------------------------------------------------------------\n`);


        // normalize() 方法可以接受一个参数来指定normalize() 的方式， 参数的四个可选值如下。

        // NFC， 默认参数， 表示“ 标准等价合成”（ Normalization Form Canonical Composition）， 返回多个简单字符的合成字符。 所谓“ 标准等价” 指的是视觉和语义上的等价。
        // NFD， 表示“ 标准等价分解”（ Normalization Form Canonical Decomposition）， 即在标准等价的前提下， 返回合成字符分解的多个简单字符。
        // NFKC， 表示“ 兼容等价合成”（ Normalization Form Compatibility Composition）， 返回合成字符。 所谓“ 兼容等价” 指的是语义上存在等价， 但视觉上不等价， 比如“ 囍” 和“ 喜喜”。（ 这只是用来举例， normalize
        //     () 方法不能识别中文。）
        // NFKD， 表示“ 兼容等价分解”（ Normalization Form Compatibility Decomposition）， 即在兼容等价的前提下， 返回合成字符分解的多个简单字符。
        //     '\u004F\u030C'.normalize('NFC').length // 1
        // '\u004F\u030C'.normalize('NFD').length // 2
        // 上面代码表示， NFC参数返回字符的合成形式， NFD参数返回字符的分解形式。

        // 不过， normalize() 方法目前不能识别三个或三个以上字符的合成。 这种情况下， 还是只能使用正则表达式， 通过 Unicode 编号区间判断。



        // 一.sort排序规则,return大于0则交换数组相邻2个元素的位置
        /* 二.arr.sort(function (a,b) {})中
              a -->代表每一次执行匿名函时候，找到的数组中的当前项；
              b -->代表当前项的后一项；
         */

        // 1.升序
        var apple = [45, 42, 10, 147, 7, 65, -74];
        // ①默认法,缺点:只根据首位排序
        console.log(apple.sort());
        // ②指定排序规则法,return可返回任何值
        console.log(apple.sort(function (a, b) {
            return a - b; //若return返回值大于0(即a＞b),则a,b交换位置
        }));


        //2.降序
        var arr = [45, 42, 10, 111, 7, 65, -74];
        console.log(apple.sort(function (a, b) {
            return b - a; //若return返回值大于零(即b＞a),则a,b交换位置
        }))
    </script>

</body>

</html>